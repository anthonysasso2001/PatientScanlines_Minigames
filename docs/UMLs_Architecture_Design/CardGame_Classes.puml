@startuml PatientScanlines_Solitaire_ClassDiagram
title Card/Solitaire Class Relationships

!theme vibrant
skinparam linetype polyline

' this is the footer containing license information, should only need to be included one but may have to re-paste on multi-page documents
center footer [[https://creativecommons.org/licenses/by-sa/4.0/ <img:https://licensebuttons.net/l/by-sa/4.0/88x31.png>]] [[https://www.gnu.org/licenses/gpl-3.0.en.html <img:https://www.gnu.org/graphics/gplv3-88x31.png>]] \n This work is licensed under a [[https://creativecommons.org/licenses/by-sa/4.0/ CC BY-SA 4.0]],\n code & software examples licensed under [[https://www.gnu.org/licenses/gpl-3.0.en.html GNU GPLv3]].

package GenericSolitaire{

    enum CardRes {
        valid
        noValue
        bothInvalid
        invalidSuit
        invalidVal
    }

    class CardRule{
        -suitMax: Int
        -valMax: Int
        ---
        +CardRule(inSuitMax: Int, inValMax:Int)
        +getSuitMax: Int
        +getValMax: Int
        ....
        +checkCard(inSuit: Int, inVal: Int): CardRes
    }

    class Card {
        -cardSuit: Int
        -cardValue: Int
        ---
        +Card(inRule: CardRule)
        +Card(inRule: CardRule, inSuit: Int?, inVal: Int?)
        ....
        setCardVals(inSuit: Int, inVal: Int): CardRes
        +copyCard(inCard): CardRes
    }

    note right of Card
        ex for french cards cardVal
        will be 0-12(non inclusive),
        with the face cards being 10-12
    end note

    class CardDeck {
        -numCards: Int
        -cards: Card[]
        ---
        +CardDeck(numDecks: Int)
        +shuffle(): Boolean
        +popCard(): Card
    }

    abstract class CardOrderRule {
        +checkPlacement(prevCard: Card,
        nextCard: Card): Boolean
    }

    note bottom of CardOrderRule
        This will be overloaded with
        specific game implementations
        for tableau, foundation, etc.
    end note

    class CardPlayRegion {
        -suitRule: {abstract} CardOrderRule[]
        ---
        +placeCard(inCard: Card): Boolean
    }

    note left of CardPlayRegion
        This will be used for the
        foundation, graveyard, &
        tableau to keep implementation
        simpler...
    end note

    class CardBoard {
        -mainDeck: CardDeck
        -tableaus: CardPlayRegion[]
        -foundations: CardPlayRegion[]
        -graveyard: CardPlayRegion
        ....
        -moveCount: Int
        ---
        +getCardFromTableau(tPos: Int): Card
        +getCardFromFoundation(fPos: Int): Card
        +getCardFromGraveyard(): Card
        +getCardFromDeck(): Card
        ....
        +placeCardOnTableau(inCard: Card): Boolean
        +placeCardOnFoundation(inCard: Card): Boolean
        +placeCardOnGraveyard(inCard: Card): Boolean
        ....
        +completeFoundation(fPos: Int): Boolean
    }

    note left of CardBoard
        This will be used by UI for game,
        with rules being calculated by
        CardPlayRegions
    end note
    CardRule <|.. CardRes : uses
    Card <|.. CardRes : uses
    Card <|-- CardRule : extends
    CardOrderRule <|.. Card : uses
    CardDeck "1" *-- "many" Card : contains
    CardPlayRegion "many" *-- "many" CardOrderRule : contains

    CardBoard "1" *-- "many" CardPlayRegion : contains
    CardBoard *-- CardDeck : contains
}

@enduml