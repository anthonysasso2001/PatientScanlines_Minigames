@startuml PatientScanlines_Solitaire_ClassDiagram
title Card/Solitaire Class Relationships

!theme vibrant
skinparam linetype polyline

' this is the footer containing license information, should only need to be included one but may have to re-paste on multi-page documents
center footer [[https://creativecommons.org/licenses/by-sa/4.0/ <img:https://licensebuttons.net/l/by-sa/4.0/88x31.png>]] [[https://www.gnu.org/licenses/gpl-3.0.en.html <img:https://www.gnu.org/graphics/gplv3-88x31.png>]] \n This work is licensed under a [[https://creativecommons.org/licenses/by-sa/4.0/ CC BY-SA 4.0]],\n code & software examples licensed under [[https://www.gnu.org/licenses/gpl-3.0.en.html GNU GPLv3]].

package GenericSolitaire{

    enum CardRes {
        valid
        noValue
        bothInvalid
        invalidSuit
        invalidVal
    }

    ' CardRule
    class CardRule{
        {static} -suitMax: Int
        {static} -valMax: Int
        ---
        +CardRule(inSuitMax: Int, inValMax:Int)
        +{get} suitMax: Int
        +{get} valMax: Int
        ....
        +checkCard(inSuit: Int, inVal: Int): CardRes
    }

    ' Card
    class Card {
        -cardSuit: Int?
        -cardValue: Int?
        ---
        +Card(inRule: CardRule, inSuit: Int?, inVal: Int?)
        +{get} suit: Int
        +{get} value: Int
        ....
        +setCardVals(inSuit: Int?, inVal: Int?): CardRes
        +copyCard(inCard): CardRes
    }
    Card <|-- CardRule : extends

    note left of Card
        ex for french cards cardVal
        will be 0-12(non inclusive),
        with the face cards being 10-12
    end note

    enum RegionType{
        drawDeck
        graveyard
        tableau
        foundation
    }

    class CardContainer {
        -cards:Card[]
        {static} -cardRule: CardRule
        {static} -regionType: RegionType
        ---
        +CardContainer(inRule: CardRule, inRType: RegionType)
        +{get} numCards: Int
        +{get} peekCards: Card[]
        +{get} peekLast: Card
        +{get} regionType: RegionType
        ....
        +clearCards(): Void
        +popCards(index: Int=-1): Card[]
        +addCards(nCards: Card[], index: Int=-1): Boolean
    }

    CardContainer "1" *-- "many" Card : contains
    CardContainer "1" *-- "1" CardRule : contains
    CardContainer "1" *-- "1" RegionType : represents

    class CardDeck {
        {static} -cycleMax: Int=0
        -cycleCount: Int=0
        -drawDeck: CardContainer
        -graveyard: CardContainer
        ---
        +CardDeck(inRule: CardRule, inNDecks: Int, inCyMax: Int=0)
        +{get} cycleCount: int
        +{get} peekDraw: Card[]
        +{get} peekLastDraw: Card
        +{get} numDraw: Int
        +{get} peekGrave: Card[]
        +{get} peekLastgrave: Card
        +{get} numGrave: Int
        ....
        +shuffle(otherCards: Card[]): Void
        +drawCards(numDraw: Int=-1): Card[]
        +addToGraveyard(numDispose: Int=1): Void
        +cycleDeck(): Boolean
    }
    CardDeck "1" *-- "2" CardContainer : contains

    struct CardOrder {
        +order: OrderDirection
        +loop: Boolean
    }

    CardOrder <|.. OrderDirection : contains

    note left of CardOrderRule
        This will be overloaded with
        specific game implementations
        for tableau, foundation, etc.
    end note

    enum OrderDirection {
        ascending
        descending
        both
    }

    class CardPlayRegion {
        -suitRule: {abstract} CardOrderRule[]
        ---
        +placeCard(inCard: Card): Boolean
    }

    note left of CardPlayRegion
        This will be used for the
        foundation, graveyard, &
        tableau to keep implementation
        simpler...
    end note

    class CardBoard {
        -mainDeck: CardDeck
        -tableaus: CardPlayRegion[]
        -foundations: CardPlayRegion[]
        -graveyard: CardPlayRegion
        ....
        -moveCount: Int
        -moveLimit: Bool
        ---
        +getCardFromTableau(tPos: Int): Card
        +getCardFromFoundation(fPos: Int): Card
        +getCardFromGraveyard(): Card
        +getCardFromDeck(): Card
        ....
        +placeCardOnTableau(inCard: Card): Boolean
        +placeCardOnFoundation(inCard: Card): Boolean
        +placeCardOnGraveyard(inCard: Card): Boolean
        ....
        +completeFoundation(fPos: Int): Boolean
    }

    note left of CardBoard
        This will be used by UI for game,
        with rules being calculated by
        CardPlayRegions.
    end note

    CardPlayRegion "many" *-- "many" OrderRule : contains

    CardBoard "1" *-- "many" CardPlayRegion : contains
    CardBoard *-- CardDeck : contains
}

@enduml